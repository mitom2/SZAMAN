.org #0
JP @osBootSequence

.include gpu.ia
.include io.ia
.include memory.ia

;Task table:
;[0] 8-bit PID
;[1] 8-bit state (0 - ready, 1 - waiting for I/O, 2 - waiting for another process, 3 - sleeping, 4 - concluded)
;[2] 8-bit A
;[3] 8-bit F
;[4] 8-bit B
;[5] 8-bit C
;[6] 8-bit D
;[7] 8-bit E
;[8] 8-bit H
;[9] 8-bit L
;[10&11] 16-bit SP
;[12&13] 16-bit IX
;[14&15] 16-bit IY
;[16&17] 16-bit active memory pages in upper half of address space (top bank is in 17, bottom bank in 16)
;[18] 8-bit gpu selected color

.define system_os_i_buffer              #16392
.define system_os_ix_buffer             #16394
.define system_os_last_task_offset      #16396
.define system_os_task_table_sizeLSB    #16398
.define system_os_task_table_sizeMSB    #16399
.define system_os_task_table_front      #16400

;Keyboard inputs table:
;[0] 8-bit PID of owner
;[1] 8-bit character code

.define system_os_keyboard_inputs_table_sizeLSB #20488
.define system_os_keyboard_inputs_table_sizeMSB #20489
.define system_os_keyboard_inputs_table_front   #20490

;The following process will be owner of all keyboard inputs
.define system_os_foreground_process_PID        #21514

;Disk inputs table - only one entry possible at all times:
;[0-511] 8-bit raw data of 512-bit disk segment

;Disk queue:
;[0] 8-bit PID
;[1-4] 32-bit segment number (from LSB to MSB)

.define system_os_disk_input_owner          #21515
.define system_os_disk_input_front          #21516
.define system_os_disk_input_queue_sizeLSB  #22030
.define system_os_disk_input_queue_sizeMSB  #22031
.define system_os_disk_input_next_up_PID    #22032
.define system_os_disk_input_queue_front    #22033

.define system_os_keyboard_handler_buffer_1 #23572

.define system_os_task_selector_ctr_1    #23574

.macro system_os_tasks
    ;TODO
.endmacro

.macro cpu_hl_to_bc
    LD B,H
    LD C,L
.endmacro

;INT vector table

;Timer
.org #256
raw @osTimerIntHandler

;Storage
.org #260
raw @osDiskIntHandler

;Keyboard
.org #264
raw @osKeyboardHandler

;IO begin
.org #268
raw @osBeginIntHandler

@osBeginIntHandler
            ;TODO
            RETI

@osTimerIntHandler
            ;Enter OS mode
            ;D' - const 0
            ;E' - const 19
            ;H' - mem offset of last executed process in tasks_table upper half
            ;L' - mem offset of last executed process in tasks_table LSB lower half
            DI
            EXX
            LD (system_os_i_buffer),IX

            ;Save process state
            LD IX, system_os_task_table_front
            cpu_hl_to_bc
            ADD IX, BC
            EXX
            LD (IX+#2),A
            PUSH AF
            LD (IX+#4),B
            LD (IX+#5),C
            LD (IX+#6),D
            LD (IX+#7),E
            LD (IX+#8),H
            LD (IX+#9),L
            POP BC
            LD (IX+#3),C
            LD HL,#0
            ADD HL,SP
            LD (IX+#10),L
            LD (IX+#11),H
            LD HL,(system_os_i_buffer)
            LD (IX+#12),L
            LD (IX+#13),H
            LD (system_os_i_buffer),IY
            LD HL,(system_os_i_buffer)
            LD (IX+#14),L
            LD (IX+#15),H
            LD HL,(MEM_pages)
            LD (IX+#16),L
            LD (IX+#17),H
            LD A,(GPU_selected_color)
            LD (IX+#18),A
            EXX
            EX AF,AF'

            ;Perform OS tasks
            system_os_tasks

            ;Select next process
            PUSH HL
            LD HL,(system_os_task_table_sizeLSB)
            LD (system_os_task_selector_ctr_1),HL
            POP HL
@osTimerIntHandlerNextProcessLoop
            ADD HL,DE
            LD A,(system_os_task_table_sizeMSB)
            CP H
            JR C,#10
            JR NZ,#10
            LD A,(system_os_task_table_sizeLSB)
            CP L
            JR C,#2
            JR NZ,#2
            LD H,D
            LD L,D
@osTimerIntHandlerNextProcess
            PUSH HL
            LD HL,(system_os_task_selector_ctr_1)
            XOR A
            SBC HL,DE
            LD (system_os_task_selector_ctr_1),HL
            CP H
            JR NZ,#4
            CP L
            JP Z,@osTimerIntHandlerNoReadyProcesses
            POP HL
            PUSH HL
            PUSH HL
            POP IX
            INC HL
            LD BC,system_os_task_table_front
            ADD HL,BC
            LD A,(HL)
            POP HL
            CP D
            JP NZ,@osTimerIntHandlerNextProcessLoop
            JR #1

@osTimerIntHandlerNoReadyProcesses
            POP HL
            PUSH HL
            LD BC,system_os_task_table_front
            ADD HL,BC
            PUSH HL
            POP IX

            ;Load IY
            LD B,D
            LD C,#14
            ADD HL,BC
            LD C,(HL)
            INC HL
            LD B,(HL)
            LD (system_os_i_buffer),BC
            LD IY,(system_os_i_buffer)

            ;Load SP
            PUSH IX
            POP HL
            LD B,D
            LD C,#10
            ADD HL,BC
            LD C,(HL)
            INC HL
            LD B,(HL)
            PUSH BC
            LD (system_os_i_buffer),IX
            POP IX
            POP HL
            LD SP,IX
            LD IX,(system_os_i_buffer)
            PUSH HL
            
            ;Load the remaining registers
            EXX
            EX AF,AF'
            LD A,(IX+#18)
            LD B,A
            GPU_system_os_setColor
            LD B,(IX+#16)
            LD C,#1
            MEM_system_os_switch_page
            LD B,(IX+#17)
            INC C
            MEM_system_os_switch_page
            LD C,(IX+#3)
            PUSH BC
            POP AF
            LD A,(IX+#2)
            LD B,(IX+#4)
            LD C,(IX+#5)
            LD D,(IX+#6)
            LD E,(IX+#7)
            LD H,(IX+#8)
            LD L,(IX+#9)
            EXX
            EX AF,AF'

            ;Load the last register - IX
            PUSH IX
            POP HL
            LD B,D
            LD C,#12
            ADD HL,BC
            LD C,(HL)
            INC HL
            LD B,(HL)
            PUSH BC
            POP IX

            ;End OS procedure
            POP HL
            LD (system_os_last_task_offset),HL
            EXX
            EX AF,AF'
            EI
            RETI

.macro system_os_get_current_PID    ;Gets current PID. Requires the CPU to be set to system (alternative) registers and PID offset of current process to be at top of the stack. Returns PID in (system) B. Invalidates C.
            PUSH HL
            LD HL,%1111111111111110
            ADD HL,SP
            LD C,(HL)
            INC HL
            LD B,(HL)
            LD HL,system_os_task_table_front
            ADD HL,BC
            LD B,(HL)
            POP HL
.endmacro

.macro system_os_signal_io_data_input   ;Owner PID in A. Invalidates A and A' (!!!).
            PUSH HL
            LD HL,system_os_task_table_front
            DEC HL
            INC HL
            CP (HL)
            JR NZ,%11111100
            XOR A
            INC HL
            LD A,(HL)
            LD (HL),#0
            CP #1
            JR NZ,#3
            EX AF,AF'
            XOR A
            EX AF,AF'
            XOR A
            LD (HL),A
            POP HL
.endmacro

;Invalidates AHL, interrupts must be disabled
@osDiskQueueAdvance
        LD HL,system_os_disk_input_queue_front
        LD A,(HL)
        LD (system_os_disk_input_next_up_PID),A
        IO_selSectStorageNoReg
        INC HL
        LD A,(HL)
        IO_out
        INC HL
        LD A,(HL)
        IO_out
        INC HL
        LD A,(HL)
        IO_out
        INC HL
        LD A,(HL)
        IO_out
        IO_beginRdStorage
        RET

@osDiskIntHandler
            DI
            EXX
            EX AF,AF'
            PUSH HL
            LD HL,system_os_disk_input_front
            IO_readStorage
            LD B,D
            LD C,IO_port
            INIR
            INIR
            LD HL,(system_os_disk_input_queue_sizeLSB)
            cpu_hl_to_bc
            LD HL,system_os_disk_input_queue_front
            LD A,(system_os_disk_input_next_up_PID)
            DEC HL
            DEC HL
            DEC HL
            DEC HL
            DEC HL
@osDiskIntHandlerLoop1
            INC HL
            INC HL
            INC HL
            INC HL
            INC HL
            CP (HL)
            JP NZ,@osDiskIntHandlerLoop1
            LD (system_os_disk_input_owner),A
            system_os_signal_io_data_input
            LD B,A
            XOR A
            PUSH DE
            LD D,H
            LD E,L
            INC HL
            INC HL
            INC HL
            INC HL
            INC HL
            PUSH HL
            LD HL,(system_os_disk_input_queue_sizeLSB)
            CP H
            JR NZ,#5
            INC A
            CP L
            JP Z,@osDiskIntHandlerQueueEmpty
            cpu_hl_to_bc
            LD HL,system_os_disk_input_queue_front
            ADD HL,BC
            POP BC
            SBC HL,BC
            DEC HL
            PUSH BC
            cpu_hl_to_bc
            POP HL
            LDIR
            POP DE
            CALL @osDiskQueueAdvance
            XOR A
@osDiskIntHandlerQueueEmpty
            CP #0
            JR Z,#3
            POP DE  ;Restore stack after conditional jump
            POP DE
            LD HL,(system_os_disk_input_queue_sizeLSB)
            DEC HL
            LD (system_os_disk_input_queue_sizeLSB),HL
            POP HL
            EX AF,AF'
            EXX
            EI
            RETI

@osKeyboardHandler
            DI
            EXX
            EX AF,AF'
            PUSH HL
            LD HL,(system_os_keyboard_inputs_table_sizeLSB)
            PUSH HL
            IO_readHID
            IO_in
            CP #0
            JP Z,@osKeyboardHandlerLoop1Finished
            LD C,A
            LD B,#0
            ADD HL,BC
            ADD HL,BC
            LD (system_os_keyboard_inputs_table_sizeLSB),HL
            POP HL
            PUSH BC
            cpu_hl_to_bc
            LD HL,system_os_keyboard_inputs_table_front
            ADD HL,BC
            POP BC
            LD B,C
            LD A,(system_os_foreground_process_PID)
            LD C,A
            system_os_signal_io_data_input
@osKeyboardHandlerLoop1
            LD (HL),C
            INC HL
            IO_in
            LD (HL),A
            INC HL
            XOR A
            DEC B
            CP B
            JP NZ,@osKeyboardHandlerLoop1
@osKeyboardHandlerLoop1Finished
            POP HL
            EX AF,AF'
            EXX
            EI
            RETI

@osRequestWaitIO
            DI
            EXX
            PUSH IX
            LD IX, system_os_task_table_front
            LD B,H
            LD C,L
            ADD IX, BC
            LD A,#1
            LD (IX+#1),A
            POP IX
            EXX
            EI
            LD A,#1
            CP #0
            JR NZ,%11111100 ;0 in A is a signal from the OS that the data is now available
            RET

.macro system_os_reserve_disk   ;Joins the disk queue. Requires segment number in (MSB)HLDE(LSB). Invalidates ABC.
    DI
    EXX
    LD BC,system_os_task_table_front
    PUSH HL
    ADD HL,BC
    LD A,(HL)
    PUSH AF
    LD HL,(system_os_disk_input_queue_sizeLSB)
    cpu_hl_to_bc
    LD HL,system_os_disk_input_queue_front
    ADD HL,BC
    INC BC
    LD A,B
    LD (system_os_disk_input_queue_sizeMSB),A
    LD A,C
    LD (system_os_disk_input_queue_sizeLSB),A
    POP AF
    LD (HL),A
    INC HL
    EXX
    PUSH HL
    PUSH DE
    EXX
    POP BC
    LD (HL),C
    INC HL
    LD (HL),B
    INC HL
    POP BC
    LD (HL),C
    INC HL
    LD (HL),B
    XOR A
    LD HL,(system_os_disk_input_queue_sizeLSB)
    CP H
    JR NZ,#5
    INC A
    CP L
    CALL Z,@osDiskQueueAdvance
    POP HL
    EXX
    EI
.endmacro

.macro system_os_wait_disk  ;Checks if disk data is available. If not, waits for it. Invalidates AHL. Enables interrupts during execution but disables them afterwards.
    DI
    EXX
    LD BC,system_os_task_table_front
    PUSH HL
    ADD HL,BC
    LD A,(HL)
    POP HL
    PUSH AF
    EXX
    POP AF
    LD HL,system_os_disk_input_owner
    CP (HL)
    JR Z,#3
    CALL @osRequestWaitIO
    DI
.endmacro

.macro system_os_free_disk  ;Moves ownership of disk data to the OS. Enables interrupts. Sets A to 0.
    XOR A
    LD (system_os_disk_input_owner),A
    EI
.endmacro

.macro system_os_get_keyboard_input ;Expects current PID in A. Invalidates BCD. Result in A. Returns 0 if no entry was found in keyboard inputs table.
    DI
    PUSH HL
    LD D,A
    LD HL,(system_os_keyboard_inputs_table_sizeLSB)
    cpu_hl_to_bc
    INC BC
    INC BC
    LD HL,system_os_keyboard_inputs_table_front
    DEC HL
    DEC HL
    INC HL
    INC HL
    DEC BC
    DEC BC
    XOR A
    CP B
    JR NZ,#3
    CP C
    JR Z,#40
    LD A,D
    CP (HL)
    JR NZ,%11111010
    INC HL
    LD A,(HL)
    LD D,H
    LD E,L
    DEC DE
    INC HL
    PUSH AF
    LD A,(system_os_keyboard_inputs_table_sizeLSB)
    LD C,A
    LD A,(system_os_keyboard_inputs_table_sizeMSB)
    LD B,A
    DEC BC
    DEC BC
    LD A,B
    LD (system_os_keyboard_inputs_table_sizeMSB),A
    LD A,C
    LD (system_os_keyboard_inputs_table_sizeLSB),A
    XOR A
    CP B
    JR NZ,#5
    CP C
    JR Z,#2
    LDIR
    POP AF
    POP HL
    EI
.endmacro

.macro system_os_wait_keyboard  ;Checks if keyboard data is available. If not, waits for it. Invalidates ABCDHL.
    XOR A
    LD HL,(system_os_keyboard_inputs_table_sizeLSB)
    CP H
    JR NZ,#6
    CP L
    CALL Z,@osRequestWaitIO
    LD HL,(system_os_keyboard_inputs_table_sizeLSB)
    LD B,H
    LD C,L
    LD HL,system_os_keyboard_inputs_table_front
    DI
    EXX
    LD BC,system_os_task_table_front
    PUSH HL
    ADD HL,BC
    LD A,(HL)
    POP HL
    PUSH AF
    EXX
    EI
    POP AF
    LD D,A
    PUSH HL
    ADD HL,BC
    LD B,H
    LD C,L
    POP HL
    LD A,D
    CP (HL)
    JR Z,#12
    INC HL
    INC HL
    LD A,B
    CP H
    JR NZ,%11111010
    LD A,C
    CP L
    JR Z,%11001010
    JR %11110000
.endmacro

@osBootSequence
            ;Initialize memory
            LD C,#0
            LD B,#0
            MEM_system_os_switch_page
            INC B
            INC C
            MEM_system_os_switch_page
            INC B
            INC C
            MEM_system_os_switch_page

            ;Prepare interrupts
            DI
            IM 2
            LD A,#1
            LD I,A

            ;Prepare OS stack
            LD      SP,%0111111111111111

            ;Create boot process entry in table with PID=1
            LD (system_os_foreground_process_PID),A
            LD (system_os_task_table_front),A
            XOR A
            LD (system_os_task_table_sizeMSB),A
            LD (system_os_last_task_offset),A
            EXX
            XOR A
            LD H,A
            LD L,A
            LD D,A
            LD E,#19
            LD A,E
            LD (system_os_task_table_sizeLSB),A
            EXX

            ;Initialize disk queue
            XOR A
            LD (system_os_disk_input_queue_sizeLSB),A
            LD (system_os_disk_input_queue_sizeMSB),A

            ;Prepare screen
            LD      B,#10
            LD      C,#0
            LD      D,#10
            LD      E,#0
            GPU_system_os_setPointer
            GPU_changeColor_white

            ;Initialize IO controller
            IO_disableInt
            IO_beginConn
            IO_cancelRead
            IO_enableInt

            ;Initialize Mass storage
            LD      A,#1
            IO_setRetMdStorage

            ;Load welcome screen from mass storage device
            XOR     A
            LD H,A
            LD L,A
            LD D,A
            LD E,A
            system_os_reserve_disk
            system_os_wait_disk
            
            ;Draw downloaded characters
            LD      HL,system_os_disk_input_front
            LD      B,(HL)
            GPU_system_os_drawChar
            INC     HL
            LD      B,(HL)
            GPU_system_os_drawChar
            INC     HL
            LD      B,(HL)
            GPU_system_os_drawChar
            INC     HL
            LD      B,(HL)
            GPU_system_os_drawChar
            INC     HL
            LD      B,(HL)
            GPU_system_os_drawChar
            INC     HL
            LD      B,(HL)
            GPU_system_os_drawChar
            INC     HL
            LD      B,(HL)
            GPU_system_os_drawChar

            ;Free disk for future processes
            system_os_free_disk

            ;Select keyboard as a HID device
            LD      A,IO_keyboard_port
            IO_selectHID

            ;Enable OS INT timer
            LD      A,IO_timer_port
            IO_selectOther
            IO_writeOther
            XOR     A
            LD      D,%00000010
            LD      E,%11111111
            IO_out
            IO_out
            LD      A,D
            IO_out
            LD      A,E
            IO_out
            LD      A,#3
            LD      B,%10000001
            IO_setFlagsOther

@osBootSequenceKeyboardLoop
            system_os_wait_keyboard
            DI
            EXX
            PUSH HL
            system_os_get_current_PID
            POP HL
            PUSH BC
            EXX
            EI
            POP BC
            LD A,B
            system_os_get_keyboard_input
            CP      #0
            JP      Z,@osBootSequenceKeyboardLoop
            LD      B,A
            GPU_drawChar
            JP      @osBootSequenceKeyboardLoop

.org %1000000000000000